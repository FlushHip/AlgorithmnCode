# 函数调用惯例

## 概览

- `__cdecl`是C/C++程序默认的调用惯例，这种调用惯例的优点是允许函数使用可变数量的参数，缺点是程序会变大；
- `__stdcall`是`WINAPI`的定义，被用于Win32的API函数，它不允许函数使用可变参数；
- `__fastcall`是把参数塞入寄存器，而不压入栈中，寄存器的操作速度快于压栈，因此会使函数调用加快；
- `thiscall`是C++成员函数的调用惯例，同样是不允许使用可变参数的。

## 当一个函数被调用时，发生了啥

不管是哪种调用惯例，以下的事情将会发生：

1. 所有参数被扩展到4字节的倍数（以Win32平台为例），然后把参数放入到恰当的内存位置，有可能是栈，也有可能是寄存器。当然，这由调用惯例规定；
2. 程序跳转到被调用函数的地址处；
3. 堆栈指针`ebp`等等寄存器保存于栈上，执行这步操作的代码叫做*function prolog*，每个函数前都会有这么一部分代码，这些代码由编译器生成；
4. 函数本身被执行，之后，把返回值置于`eax`寄存器，函数返回；
5. 第三步被保存的寄存器从栈中恢复，执行这步操作的代码叫做*function epilog*，每个函数前都会有这么一部分代码，这些代码由编译器生成；
6. 所有参数从栈上移除，这步操作叫**堆栈清理**（也叫**堆栈平衡**），这步操作可以由调用者完成，也可以由被调用者完成，这取决与函数调用惯例。

在具体代码上添加具体调用惯例来展示步骤，会以Win32的汇编作为演示。

## 何为调用惯例

当函数被调用时，需要传递参数给函数，同时还需取回返回值。调用惯例描述**参数如何传递给函数和返回值如何返回**，同时它还描述**函数名如何被修饰**。平时你可能接触不到调用惯例，但是如果你是库的作者，或者调试，或者反编译时，调用惯例就显得很重要了。

由于绝大部分调用惯例传参都是通过压栈的方式（`__fastcall`通过寄存器传参），因此，**栈的清理（堆栈平衡）的工作到底是由调用者来完成还是由被调用者来完成**，这也是调用惯例所规定的。

## `__cdecl`调用惯例



------

参考：

- [Calling Conventions Demystified](https://www.codeproject.com/Articles/1388/Calling-Conventions-Demystified)

- [The history of calling conventions, part 1](https://devblogs.microsoft.com/oldnewthing/20040102-00/?p=41213)

- [The history of calling conventions, part 2](https://devblogs.microsoft.com/oldnewthing/20040107-00/?p=41183)

- [The history of calling conventions, part 3](https://devblogs.microsoft.com/oldnewthing/20040108-00/?p=41163)

- [The history of calling conventions, part 4](https://devblogs.microsoft.com/oldnewthing/20040113-00/?p=41073)

- [The history of calling conventions, part 5](https://devblogs.microsoft.com/oldnewthing/20040114-00/?p=41053)

